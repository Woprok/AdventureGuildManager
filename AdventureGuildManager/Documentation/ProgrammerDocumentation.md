## Programmer Documentation

### Introduction
This program has been coded in VS2019. 
Solution contains:  
	- Current documentation 
	- Old specification document's and old source code (primarily for my future me).    
	- Project AdventureGuildManager  

### Compilation
Preferably compile with VS2019 and C++20/latest. 
On older standard it could fail as it uses at least one function that is not part of previous standards.  

### Description  
See UserDocumentation for overview what is this and how to use it.  

### Short overview of how this works
Game is controlled by GameManager, which read's user input and tries to translate it to command.  
Afterward command is executing with current GameDataManager.   
Each command has a function in GameDataManager that is responsible for it's functionality.  
Result of this function is used to decide which interface to show, either some result information... or error message, 
if command was not executed at all (wrong parameters, insufficient resources).  
Finally GameManager checks win/lose condition and proceeds to next user command.  

### Project structure
Follows default file layout of c++ project in visual studio 2019...
Almost all code is in header files (not optimal, but due to amount of files currently it's easier to maintain)

Program flow is controlled by GameManager (GameManagers.hpp)  
	- Holds all defined commands.  
	- Handles game loop.  

ICommands serves as simple interface for each command. (Interfaces/ICommands.hpp)  
	- Each command has to fulfill:  
		- can_derive_from(...) // testing user input, if it's this command.  
		- execute(...) // calling proper method to evaluate self.  
	- All commands are grouped by category and located in single header file at (UserCommands/*.hpp)
		- Almost all (exclude DebugCommands) have same structure:  
			- parse additional input  
			- call method on GameDataManager  
			- return interface based on result  

IDisplayableInterface is basic predecessor for all user interfaces (Intefaces/IDisplayableInterfaces.hpp)  
	- All interfaces are declared in UserInterfaces/*.hpp  
		- SharedCovnertors.hpp, InputInterfaces.hpp hold several static function used by several interfaces.  
		- Most interfaces are dependant on GameDataManager to show their context.
		Through this could be reduced to just one or two DataKeepers in current user interface versions, 
		but to provide more cohesive information to user you would eventually need to give them all DataKeepers, which is same as now.

Main entities of the game are:  
- Quest  
	- Each instance represents one quest.  
		- Quest has several fields (difficulty, rarity, reward, penalty, state, QuestTypes)    
	- Quests are kept by QuestDataKeeper (DataKeepers/QuestDataKeepers.hpp) and generated by QuestGenerator (Generators/QuestGenerators.hpp)
			- QuestDataKeeper provides set of methods for manipulating state of quests currently in game.  

- Adventurer  
	- Each instance represents one adventurer.   
		- Adventurer has several fields (exp, rarity, retire/recruit/living cost, quests completed/failed)  
	- And his own collection of skill that he currently has.  
	- Adventures are kept by AdventurerDataKeeper (DataKeepers/AdventurerDataKeepers.hpp) and generated by AdventurerGenerator (Generators/AdventurerGenerators.hpp)  
		- AdventurerDataKeeper provides set of methods for manipulating state of adventurer currently in game.  

- Guild  
	- Holds some information about player progress in the game such as Gold, Fame, and Perks.  
	- All method provided are related to getting/setting or reseting state of data.  

- Skill  
	- Defined by ISkill (Interfaces/ISkill.hpp) is simple declaration of skill that has several methods, based on location where they are executed.  
	- All skills are then defined in (Skills/*.hpp) as now there are two main types, one that affect QuestTypes and other that change Quest dispatch functionality.   
	- Skills are managed by SkillDataKeeper (DataKeepers/SkillDataKeepers.hpp)    
		- Holds all skill creators and provides generation & creation function, which is used primarely by AdventurerGenerator.  

- Perk  
	- Defined by IPerk (Interfaces/IPerk.hpp) is declaration of Guild Perks that has two functionalities:  
		- Provides a way how to declare perk that can be obtained by guild, as well as some information name, description, level, id...
		- Provides interface similiar to ISkill that is called from different places based on execution context.
		- Finally by PERK_ID binds self to PerkCommand defined in PerkCommands.hpp.
		- All current perks are implemented in Perks/Perks.hpp
	- During runtime perks are holded and created by PerkDataKeeper (DataKeepers/PerkDataKeepers.hpp)
		- After buying perk, they are holded by current Guild instance.

Finally and most importantly there is GameDataManager (GameDataManagers.hpp and GameDataManagers.cpp, GameDataManagerDispatch.cpp)  
	- Hold's all data and provides all actions for commands.
	- For more information see header file as it has comment about each declared function as well as declaration of all fields.

All other files are for helping methods that are used at few places like  
	- ConsoleProcessors.hpp and ConsoleHelpers.hpp, used mostly to parse user input and dispaly interfaces.   
	- NeutrlaGenerators.hpp that is just wrapper around random library to provide less annoying interface to use.   
	- CollectionIterators.hpp are template function to simplify finding and exchanging elements of DataKeepers.   
	- EntityCreators.hpp are used to create entities such as Skills and Perks...   
	- StringContexts.hpp is wrapper around vector of strings and set of strings and provide function to merge them into single string.  

Global configuration constants declared in several headers such as constexpr are used for reconfigurable values used mostly for balance or synchronizing some values across different files.  
They were created as temporary and fast solution to provide easy option to change balance values and keep some entity ids synchronized in project.  

### Optimality and Future  
As it stands now, at several places a better data structures and data organization should have been used.  
Right now it fulfills basic premise of sending adventurers on quests and evaluating result.  
Currently the game design is really questionable, but most importanly architecture of this program is not optimal. 
It would have been better to use different approach to holding game data and how are commands evaluated.  
Main place which seriosly shows bad choice is handling of skills and perks, which would be preferable to refactor if this project should continue in any form.  
Due to current project architecture it might be complicated to continue in original vision from two years ago for this project.
